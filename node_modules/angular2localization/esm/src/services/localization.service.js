/**
 * ANGULAR 2 LOCALIZATION
 * An Angular 2 library to translate messages, dates and numbers.
 * Written by Roberto Simonetti.
 * MIT license.
 * https://github.com/robisim74/angular2localization
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { Injectable } from '@angular/core';
import { Http } from '@angular/http';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/map';
import { LocaleService } from './locale.service';
import { IntlSupport } from './Intl-support';
/**
 * LocalizationService class.
 * Gets the translation data and performs operations.
 *
 * Direct loading.
 *
 * To initialize LocalizationService for the direct loading, add the following code in the body of constructor of the route component:
 *
 * var translationEN = {
 *      TITLE: 'Angular 2 Localization',
 *      CHANGE_LANGUAGE: 'Change language',
 *      ...
 * }
 * // Add a new translation here.
 *
 * // Required: adds a new translation with the given language code.
 * this.localization.addTranslation('en', translationEN);
 * // Add a new translation with the given language code here.
 * this.localization.updateTranslation(); // Need to update the translation.
 *
 * Asynchronous loading.
 *
 * To initialize LocalizationService for the asynchronous loading, add the following code in the body of constructor of the route component:
 *
 * // Required: initializes the translation provider with the given path prefix.
 * this.localization.translationProvider('./resources/locale-');
 * this.localization.updateTranslation(); // Need to update the translation.
 *
 * and create the json files of the translations such as 'locale-en.json':
 *
 * {
 *     "TITLE": "Angular 2 Localization",
 *     "CHANGE_LANGUAGE": "Change language",
 *     ...
 * }
 *
 * @author Roberto Simonetti
 */
export let LocalizationService = class LocalizationService {
    constructor(http, locale) {
        this.http = http;
        this.locale = locale;
        /**
         * The translation data: {languageCode: {key: value}}.
         */
        this.translationData = {};
        this.prefix = "";
        this.loadingMode = LoadingMode.Unknown;
        this.languageCode = "";
        // Initializes the loading mode.
        this.loadingMode = LoadingMode.Direct;
        // Initializes the service state.
        this.serviceState = ServiceState.isWaiting;
        // When the language changes, subscribes to the event & call updateTranslation method.
        this.locale.languageCodeChanged.subscribe(
        // Generator or next.
            (language) => this.updateTranslation(language));
    }
    /**
     * Direct loading: adds new translation data.
     *
     * @param language The two-letter code of the language for the translation data
     * @param translation The new translation data
     */
    addTranslation(language, translation) {
        // Adds the new translation data.
        this.translationData[language] = translation;
    }
    /**
     * Asynchronous loading: defines the translation provider.
     *
     * @param prefix The path prefix of the json files
     * @param dataFormat Data format: default value is 'json'.
     * @param webAPI True if the asynchronous loading uses a Web API to get the data.
     */
    translationProvider(prefix, dataFormat = "json", webAPI = false) {
        this.prefix = prefix;
        this.dataFormat = dataFormat;
        this.webAPI = webAPI;
        // Updates the loading mode.
        this.loadingMode = LoadingMode.Async;
    }
    /**
     * Translates a key.
     *
     * @param key The key to be translated
     * @return The value of translation
     */
    translate(key) {
        var value;
        if (this.translationData[this.languageCode] != null) {
            // Gets the translation by language code. 
            var translation = this.translationData[this.languageCode];
            // Gets the value of translation by key.   
            value = translation[key];
        }
        // If the value of translation is not present, the same key is returned (see issue #1).
        if (value == null || value == "") {
            value = key;
        }
        return value;
    }
    /**
     * Translates a key.
     *
     * @param key The key to be translated
     * @return An observable of the value of translation
     */
    translateAsync(key) {
        return new Observable((observer) => {
            // Gets the value of translation for the key.
            var value = this.translate(key);
            observer.next(value);
            observer.complete();
        });
    }
    /**
     * Updates the language code and loads the translation data for the asynchronous loading.
     *
     * @param language The two-letter or three-letter code of the language
     */
    updateTranslation(language = this.locale.getCurrentLanguage()) {
        if (language != "" && language != this.languageCode) {
            // Asynchronous loading.
            if (this.loadingMode == LoadingMode.Async) {
                // Updates the translation data.  
                this.getTranslation(language);
            }
            else {
                // Updates the language code of the service.
                this.languageCode = language;
                // Updates the service state.
                this.serviceState = ServiceState.isReady;
            }
        }
    }
    /* Intl.Collator */
    /**
     * Compares two keys by the value of translation & the current language code.
     *
     * @param key1, key2 The keys of the values to compare
     * @param extension
     * @param options
     * @return A negative value if the value of translation of key1 comes before the value of translation of key2; a positive value if key1 comes after key2; 0 if they are considered equal or Intl.Collator is not supported
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     */
    compare(key1, key2, extension, options) {
        // Checks for support for Intl.
        if (IntlSupport.Collator(this.languageCode) == false) {
            return 0;
        }
        // Gets the value of translation for the keys.
        var value1 = this.translate(key1);
        var value2 = this.translate(key2);
        var locale = this.addExtension(this.languageCode, extension);
        return new Intl.Collator(locale).compare(value1, value2);
    }
    /**
     * Sorts an array of objects or an array of arrays by the current language code.
     *
     * @param list The array to be sorted
     * @param keyName The column that contains the keys of the values to be ordered
     * @param order 'asc' or 'desc'. The default value is 'asc'.
     * @param extension
     * @param options
     * @return The same sorted list or the same list if Intl.Collator is not supported
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     */
    sort(list, keyName, order, extension, options) {
        if (list == null || keyName == null || IntlSupport.Collator(this.languageCode) == false) {
            return list;
        }
        // Gets the value of translation for the keys.
        for (let item of list) {
            // Gets the value of translation for the key.
            var value = this.translate(item[keyName]);
            // Adds a new column for translated values.
            var translated = keyName.concat("Translated");
            // Updates the value in the list.
            item[translated] = value;
        }
        var locale = this.addExtension(this.languageCode, extension);
        // Intl.Collator.
        var collator = new Intl.Collator(locale, options); // It can be passed directly to Array.prototype.sort.
        list.sort((a, b) => {
            return collator.compare(a[translated], b[translated]);
        });
        // Removes the column of translated values.
        var index = list.indexOf(translated, 0);
        if (index > -1) {
            list.splice(index, 1);
        }
        // Descending order.
        if (order != null && order == "desc") {
            list.reverse();
        }
        return list;
    }
    /**
     * Sorts an array of objects or an array of arrays by the current language code.
     *
     * @param list The array to be sorted
     * @param keyName The column that contains the keys of the values to be ordered
     * @param order 'asc' or 'desc'. The default value is 'asc'.
     * @param extension
     * @param options
     * @return An observable of the sorted list or of the same list if Intl.Collator is not supported
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     */
    sortAsync(list, keyName, order, extension, options) {
        return new Observable((observer) => {
            // Gets the sorted list.
            observer.next(this.sort(list, keyName, order, extension, options));
            observer.complete();
        });
    }
    /**
     * Matches a string into an array of objects or an array of arrays.
     *
     * @param s The string to search
     * @param list The array to look for
     * @param keyNames An array that contains the columns to look for
     * @param options
     * @return A filtered list or the same list if Intl.Collator is not supported
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     */
    search(s, list, keyNames, options = { usage: 'search' }) {
        if (list == null || keyNames == null || s == "" || IntlSupport.Collator(this.languageCode) == false) {
            return list;
        }
        // Gets the value of translation for the each column.
        var translated = new Array();
        var i = 0;
        for (var i = 0; i < keyNames.length; i++) {
            // Adds a new column for translated values.
            translated.push(keyNames[i].concat("Translated"));
            for (let item of list) {
                // Gets the values of translation for the column.
                var value = this.translate(item[keyNames[i]]);
                // Updates the value in the list.
                item[translated[i]] = value;
            }
        }
        var locale = this.languageCode;
        // Intl.Collator.
        var collator = new Intl.Collator(locale, options);
        var matches = list.filter((v) => {
            var found = false;
            for (var i = 0; i < translated.length; i++) {
                // Calls matching algorithm.
                if (this.match(v[translated[i]], s, collator)) {
                    found = true;
                    break;
                }
            }
            return found;
        });
        // Removes the columns of translated values.
        for (var i = 0; i < translated.length; i++) {
            var index = matches.indexOf(translated[i], 0);
            if (index > -1) {
                matches.splice(index, 1);
            }
        }
        return matches;
    }
    /**
     * Matches a string into an array of objects or an array of arrays.
     *
     * @param s The string to search
     * @param list The array to look for
     * @param keyNames An array that contains the columns to look for
     * @param options
     * @return An observable for each element of the filtered list or the same list if Intl.Collator is not supported
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     */
    searchAsync(s, list, keyNames, options = { usage: 'search' }) {
        if (list == null) {
            return null;
        }
        if (keyNames == null || s == "" || IntlSupport.Collator(this.languageCode) == false) {
            return new Observable((observer) => {
                for (let item of list) {
                    observer.next(item);
                }
                observer.complete();
            });
        }
        return new Observable((observer) => {
            // Gets the value of translation for the each column.
            var translated = new Array();
            var i = 0;
            for (var i = 0; i < keyNames.length; i++) {
                // Adds a new column for translated values.
                translated.push(keyNames[i].concat("Translated"));
                for (let item of list) {
                    // Gets the values of translation for the column.
                    var value = this.translate(item[keyNames[i]]);
                    // Updates the value in the list.
                    item[translated[i]] = value;
                }
            }
            var locale = this.languageCode;
            // Intl.Collator.
            var collator = new Intl.Collator(locale, options);
            for (let v of list) {
                for (var i = 0; i < translated.length; i++) {
                    // Calls matching algorithm.
                    if (this.match(v[translated[i]], s, collator)) {
                        observer.next(v);
                        break;
                    }
                }
            }
            // Removes the columns of translated values.
            for (var i = 0; i < translated.length; i++) {
                var index = list.indexOf(translated[i], 0);
                if (index > -1) {
                    list.splice(index, 1);
                }
            }
            observer.complete();
        });
    }
    addExtension(locale, extension) {
        // Adds extension.
        if (extension != null && extension != "") {
            locale = locale + "-" + extension;
        }
        return locale;
    }
    /**
     * Matching algorithm.
     *
     * @param v The value
     * @param s The string to search
     * return True if match, otherwise false
     */
    match(v, s, collator) {
        var vLength = v.length;
        var sLength = s.length;
        if (sLength > vLength) {
            return false;
        } // The search string is longer than value.
        if (sLength == vLength) {
            return collator.compare(v, s) === 0;
        }
        // Tries to search the substring.
        var found = false;
        for (var i = 0; i < vLength - (sLength - 1); i++) {
            var str = v.substr(i, sLength);
            if (collator.compare(str, s) === 0) {
                found = true;
                break;
            }
        }
        return found;
    }
    /**
     * Asynchronous loading: gets translation data.
     *
     * @param language The two-letter or three-letter code of the language
     */
    getTranslation(language) {
        // Initializes the translation data & the service state.
        this.translationData = {};
        this.serviceState = ServiceState.isLoading;
        // Builds the URL.
        var url = this.prefix;
        if (this.webAPI == true) {
            // Absolute URL for Web API.
            url += language;
        }
        else {
            // Relative server path for 'json' files.
            url += language + "." + this.dataFormat;
        }
        // Angular 2 Http module.
        this.http.get(url)
            .map((res) => res.json())
            .subscribe(
        // Observer or next.
            (res) => {
            // Assigns the observer to the translation data.
            this.translationData[language] = res;
        }, 
        // Error.
            (error) => {
            console.error("Localization service:", error);
        }, 
        // Complete.
            () => {
            // Updates the service state.
            this.serviceState = ServiceState.isReady;
            // Updates the language code of the service.
            this.languageCode = language;
        });
    }
};
LocalizationService = __decorate([
    Injectable(), 
    __metadata('design:paramtypes', [Http, LocaleService])
], LocalizationService);
/**
 * Defines the service state.
 */
export var ServiceState;
(function (ServiceState) {
    /**
     * The translation data has been loaded.
     */
    ServiceState[ServiceState["isReady"] = 0] = "isReady";
    /**
     * The service is loading the data.
     */
    ServiceState[ServiceState["isLoading"] = 1] = "isLoading";
    /**
     * The service is waiting for the data.
     */
    ServiceState[ServiceState["isWaiting"] = 2] = "isWaiting";
})(ServiceState || (ServiceState = {}));
/**
 * Defines the loading mode.
 */
export var LoadingMode;
(function (LoadingMode) {
    /**
     * Initial state.
     */
    LoadingMode[LoadingMode["Unknown"] = 0] = "Unknown";
    /**
     * Direct loading.
     */
    LoadingMode[LoadingMode["Direct"] = 1] = "Direct";
    /**
     * Asynchronous loading.
     */
    LoadingMode[LoadingMode["Async"] = 2] = "Async";
})(LoadingMode || (LoadingMode = {}));

//# sourceMappingURL=localization.service.js.map
